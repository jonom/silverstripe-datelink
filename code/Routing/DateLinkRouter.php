<?php

/**
 * Handles all routing pattern setup within the Silverstripe routing tables
 * 
 * @package datelink
 * @author Damian Mooyman
 */
class DateLinkRouter extends SS_Object implements IDateLinkRouter {

	protected function getCacheFilePath() {
		return ASSETS_PATH . '/' . DateLink::config()->route_cache;
	}

	/**
	 * Registers all cached routes with silverstripe 
	 */
	public function RegisterRoutes() {
		$cachePath = $this->getCacheFilePath();
		if (!file_exists($cachePath)) {
			return Debug::message('DateLink route cache file could not be found. This can be generated by using /dev/build');
		}

		$document = new DOMDocument();
		$document->load($cachePath);

		foreach ($document->getElementsByTagName('route') as $route) {
			$link = $route->getElementsByTagName('link')->item(0)->nodeValue;
			$parentID = $route->getElementsByTagName('page_id')->item(0)->nodeValue;
			$years = $route->getElementsByTagName('year');
			foreach ($years as $year) {
				$this->registerRoute($link, $parentID, $year->nodeValue);
			}
		}
	}

	/**
	 * Registers a single routing rule within silverstripe
	 * @param string $parentLink The link of the parent page
	 * @param integer $parentID The ID of the parent page
	 * @param integer $yearNumber The value of the $Year parameter
	 */
	protected function registerRoute($parentLink, $parentID, $yearNumber) {
		$parentLink = trim($parentLink, '/');
		$pattern = DateLink::config()->url_pattern;

		// Replace wildcards in pattern
		// Substitute leading-zero indicators
		$pattern = preg_replace('/#\$/', '$', $pattern);
		// substitute the year
		$pattern = preg_replace('/\$Year!?/i', $yearNumber, $pattern);
		// substitute parent url
		$pattern = preg_replace('/\$ParentLink!?/i', $parentLink, $pattern);
		// Fix any extra slashes, which may occur if the $parentLink is /
		$pattern = trim($pattern, '/');

		// Registers a route with silverstripe
		$routes = array($pattern => array(
			'Controller' => DateLink::config()->controller,
			'ParentID' => $parentID, // Used as a shortcut for simplifying nested routing
			'Year' => $yearNumber
		));
		
		Config::inst()->update('Director', 'rules', $routes);
	}

	/**
	 * Determines the distinct years in the set of all pages given
	 * 
	 * @param SS_List $pages
	 */
	protected function determineYears($pages) {
		$years = array();
		if($pages) foreach ($pages as $page) {
			$date = $page->getRouteDate();
			if (empty($date)) continue;
			$parsedDate = date_parse($date);
			$years[] = $parsedDate['year'];
		}
		return array_unique($years);
	}

	/**
	 * Instructs the module to refresh the routing XML cache file
	 * This may not be called during manifest initialisation (_config.php) as database access is not available
	 */
	public function RefreshCache() {
		// Builds XML cache file using all available routes
		$document = new DOMDocument();
		$document->formatOutput = true;
		$routes = $document->createElement('routes');
		$document->appendChild($routes);

		// append all routes
		$holderClasses = DateLink::config()->holder_classes;
		foreach ($holderClasses as $className) {
			foreach (DataObject::get($className) as $holderPage) {
				$route = $document->createElement('route');
				$link = $document->createElement('link', $holderPage->RelativeLink());
				$route->appendChild($link);
				$id = $document->createElement('page_id', $holderPage->ID);
				$route->appendChild($id);

				// Run through children and pull out all distinct year fields
				// We must use years in our URLS to distinguish all routes from non-numeric routes such as
				// page actions. It's not necessary to consider months, as by then the route will be sufficiently
				// distinguished.
				$children = $holderPage->AllChildren();
				$yearList = $this->determineYears($children);
				$years = $document->createElement('years');
				foreach ($yearList as $yearNumber) {
					$year = $document->createElement('year', $yearNumber);
					$years->appendChild($year);
				}
				$route->appendChild($years);
				$routes->appendChild($route);
			}
		}

		// Ensure output directory exists
		$outputPath = $this->getCacheFilePath();

		Filesystem::makeFolder(dirname($outputPath));
		$document->save($outputPath);
	}

}
